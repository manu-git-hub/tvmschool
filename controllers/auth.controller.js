const db = require('../models');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken'); 
const nodemailer = require('nodemailer');
const mailConfig = require('../config/mail.config');
const Role = db.role;
const { AppError } = require('../middleware/errorHandler');


exports.signup = async (req, res) => {
  try {
    const { username, email, role } = req.body;

    // Validate role
    if (!['admin', 'faculty', 'supervisor'].includes(role)) {
      return res.status(400).send({ message: 'Invalid role!' });
    }

    // Check for duplicate email
    const existingEmail = await db.user.findOne({ where: { email } });
    if (existingEmail) return res.status(400).send({ message: 'Email already exists!' });

    // Generate random password
    const autoGeneratedPassword = Math.random().toString(36).slice(-8);

    // Hash password
    const hashedPassword = bcrypt.hashSync(autoGeneratedPassword, 8);

    // Calculate the next sequential ID
    const maxId = await db.user.max('id') || 0;
    const nextId = maxId + 1;

    // Create user with the manually assigned ID
    const user = await db.user.create({
      id: nextId, // Assign the sequential ID
      userID: String(nextId).padStart(4, '0'), // Generate userID with leading zeros
      username,
      email,
      password: hashedPassword,
    });

    // Assign role
    const roles = await Role.findAll({ where: { name: role } });
    await user.setRoles(roles);

    // Send email with credentials
    const transporter = nodemailer.createTransport(mailConfig);

    const mailOptions = {
      from: mailConfig.auth.user,
      to: email,
      subject: 'Your Account Details',
      text: `Hello ${username},\n\nYour account has been created successfully!\n\nYour credentials:\nUserID: ${user.userID}\nPassword: ${autoGeneratedPassword}\n\nYou can now log in.\n\nBest regards,\nYour Team`,
    };

    try {
      await transporter.sendMail(mailOptions);
      console.log('Email sent successfully.');
      res.status(201).send({
        message: `User registered successfully with role: ${role}.`,
        userID: user.userID,
        password: autoGeneratedPassword,
      });
    } catch (error) {
      console.error('Error sending email:', error.message);
      return res.status(500).send({ message: 'User registered but email could not be sent.' });
    }
  } catch (error) {
    console.error('Signup Error:', error.message);
    res.status(500).send({ message: 'An error occurred during registration.' });
    next(error);
  }
};



exports.signin = async (req, res) => {
  try {
    const { identifier, password } = req.body; // identifier can be userID or email

    let user;

    // Determine if identifier is email or userID
    if (identifier.includes('@')) {
      // Admin login using email
      user = await db.user.findOne({ where: { email: identifier } });
      if (!user) return res.status(404).send({ message: 'Admin not found!' });

      const roles = await user.getRoles();
      if (!roles.some((role) => role.name === 'admin')) {
        return res.status(403).send({ message: 'Only admins can log in with email.' });
      }
    } else {
      // Faculty/Supervisor login using userID
      user = await db.user.findOne({ where: { userID: identifier } });
      if (!user) return res.status(404).send({ message: 'User not found!' });
    }

    // Validate password
    const passwordIsValid = bcrypt.compareSync(password, user.password);
    if (!passwordIsValid) return res.status(401).send({ message: 'Invalid password!' });

    // Generate JWT
    const roles = await user.getRoles();
    const token = jwt.sign({ id: user.id, role: roles[0].name }, process.env.SECRET_KEY, { expiresIn: 86400 });

    req.session.token = token;

    res.status(200).send({
      id: user.id,
      username: user.username,
      roles: roles.map((role) => role.name),
      token,
    });
  } catch (error) {
    const existingUser = await db.user.findOne({ where: { email } });
    if (existingUser) return res.status(400).send({ message: 'Email already exists!' });

    res.status(500).send({ message: error.message });
  }
};



exports.logout = async (req, res) => {
  try {
    const token = req.headers['authorization']?.split(' ')[1];
    if (!token) {
      return res.status(400).send({ message: 'Token is required for logout.' });
    }

    // Decode the token to get its expiration time
    const decoded = jwt.decode(token);
    const expiresAt = new Date(decoded.exp * 1000); // Convert UNIX timestamp to JavaScript Date

    // Store the token in the blacklist
    await db.token_blacklist.create({
      token: token,
      expires_at: expiresAt,
    });

    req.session = null; // Clear the session (if any)
    res.status(200).send({ message: 'User logged out successfully!' });
  } catch (error) {
    console.error('Logout Error:', error.message);
    res.status(500).send({ message: 'An error occurred during logout.' });
  }
};
